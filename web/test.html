<!DOCTYPE html>
<html>

<head>
    <title>My first Ethereum web page</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@4.8.0/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ganache@7.9.2/dist/web/ganache.min.js"></script>
    <script src="https://unpkg.com/vue@3"></script>
    <style>
        html,
        body {
            font-family: Arial, sans-serif;
            font-size: 10pt;
            font-size: 10pt;
        }

        table {
            border-collapse: collapse;
        }

        table,
        th,
        td {
            border: 1px solid black;
        }

        th,
        td {
            padding: 5px;
        }

        [v-cloak] {
            display: none;
        }

        .player-list {
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>

<body>
    <div id="app" v-cloak>

        <table>
            <thead>
                <tr>
                    <td>身分</td>
                    <td>帳號</td>
                    <td>餘額</td>
                    <td>操作</td>
                    <td>時間</td>
                    <td>押注</td>
                    <td>點數</td>
                    <td>得分</td>
                    <td>輸贏</td>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(player,i) in players">
                    <td>
                        {{ i === 0 ? '莊家' : '玩家' + i }}
                    </td>
                    <td>{{player.account}}</td>
                    <td>{{player.balance}}</td>
                    <td>
                        <div v-show="contractAddress">
                            <button v-show="i == 0 && !deposited" @click="deposit">儲金</button>
                            <button v-show="i == 0 && (!started || ended) && deposited" @click="startGame">開局</button>
                            <button v-show="i == 0 && started" @click="endGame">擲骰子</button>
                            <button v-show="i > 0 && started" @click="joinGame(player)">下注</button>
                        </div>
                    </td>
                    <td>
                        {{player.time}}
                    </td>
                    <td>
                        {{player.stake}}
                    </td>
                    <td>
                        {{player.dice}}
                    </td>
                    <td>
                        {{player.score}}
                    </td>
                    <td>
                        {{player.result}}
                    </td>
                </tr>
            </tbody>
        </table>
        <p>
            <button v-show="!contractAddress" @click="deployContract">Deploy</button>
            Contract Address: {{contractAddress}}
        </p>

    </div>
    <script>
        // 產生四個 1-6 隨機數字
        const throwDice = () => [1, 2, 3, 4].map(() => Math.floor(Math.random() * 6 + 1));
        // 估算骰子點數：一色 99，十八 12，BG 3，無效組合，其他 4-11
        const evalDice = (dice) => {
            const groups = {};
            // 以點數分組
            dice.forEach(p => {
                if (groups[p]) {
                    groups[p]++;
                } else {
                    groups[p] = 1;
                }
            });
            // 點數群組
            let points = Object.keys(groups);
            let grpCount = points.length;
            // 群組數量為 1，四個點數相同，一色
            if (grpCount == 1) return 99; // 一色
            // 兩顆點數相同，其餘兩個顯數不同
            if (grpCount == 3) {
                // 過濾只有顆數為一的點數
                let [a, b] = points.filter(p => groups[p] != 2);
                // 二者相加即為結果
                return parseInt(a) + parseInt(b);
            }
            // 兩對，取數字大者
            if (grpCount == 2 && groups[points[0]] == 2) {
                let [a, b] = points;
                if (a > b) return a * 2;
                return b * 2;
            }
            // 其餘狀況無效，傳回 -1
            return -1;
        }
        function getValidDice() {
            while (true) {
                let dice = throwDice();
                if (evalDice(dice) == -1) continue;
                return dice;
            }
        }

    </script>
    <script>
        const gasLimit = 3000000;
        const options = {};
        //const provider = Ganache.provider(options);
        const provider = new Web3.providers.HttpProvider("http://localhost:7545");
        const web3 = new Web3(provider);
        const app = Vue.createApp({
            data() {
                return {
                    accounts: [],
                    dealer: '',
                    dealerBalance: 0,
                    players: [],
                    contractAddress: null,
                    abi: [],
                    bytecode: '',
                    deposited: false,
                    started: false,
                    ended: false,
                }
            },
            async created() {
                this.accounts = await web3.eth.getAccounts();
                this.dealer = this.accounts[0];
                for (let i = 0; i < 6; i++) {
                    this.players.push({
                        account: this.accounts[i],
                        balance: 0,
                        time: '',
                        stake: '',
                        dice: '',
                        score: '',
                        result: ''
                    });
                }
                const self = this;
                fetch("DiceGame.json").then(response => response.json()).then(info => {
                    self.abi = info.abi;
                    self.bytecode = info.bytecode;
                });
                this.refreshBalances();
            },
            methods: {
                async deployContract() {
                    const contract = new web3.eth.Contract(this.abi);
                    contract.options.data = '0x' + this.bytecode;
                    const deployTx = contract.deploy();
                    const deployedContract = await deployTx.send({
                        from: this.dealer,
                        gas: gasLimit
                        //gas: await deployTx.estimateGas() * 10
                    });
                    this.contractAddress = deployedContract.options.address;
                    this.refreshBalances();
                },
                async deposit() {
                    const contract = new web3.eth.Contract(this.abi, this.contractAddress);
                    const tx = contract.methods.deposit();
                    try {
                        await tx.send({
                            from: this.dealer,
                            value: web3.utils.toWei('1', 'ether'),
                            gas: gasLimit
                        });
                        this.deposited = true;
                        this.refreshBalances();
                    }
                    catch (error) {
                        console.error(error);
                    }
                },
                async startGame() {
                    const contract = new web3.eth.Contract(this.abi, this.contractAddress);
                    tx = contract.methods.startGame();
                    try {
                        await tx.send({
                            from: this.dealer,
                            gas: gasLimit
                        });
                        this.started = true;
                        this.ended = false;
                        this.players.map(player => {
                            player.time = '';
                            player.stake = '';
                            player.dice = '';
                            player.score = '';
                            player.result = '';
                        });
                        this.refreshBalances();
                    }
                    catch (error) {
                        console.error(error);
                    }
                },
                async endGame() {
                    const contract = new web3.eth.Contract(this.abi, this.contractAddress);
                    const tx = contract.methods.endGame();
                    try {
                        await tx.send({
                            from: this.dealer,
                            gas: gasLimit
                        });
                        this.refreshBalances();
                        this.started = false;
                        this.ended = true;
                        this.showGameStatus();
                    }
                    catch (error) {
                        console.error(error);
                    }
                },
                async joinGame(player) {
                    const contract = new web3.eth.Contract(this.abi, this.contractAddress);
                    const tx = contract.methods.joinGame();
                    try {
                        await tx.send({
                            from: player.account,
                            value: web3.utils.toWei("0.1", 'ether'),
                            gas: gasLimit //await tx.estimateGas()
                        });
                        this.refreshBalances();
                        this.showGameStatus();
                    }
                    catch (error) {
                        console.error(error);
                    }
                },
                async showGameStatus() {
                    const contract = new web3.eth.Contract(this.abi, this.contractAddress);
                    const gamePlayers = await contract.methods.getPlayers().call();
                    console.log(gamePlayers);
                    const self = this;
                    let dealerBalance = 0;
                    const dealerPlayer = self.players[0];
                    const delearScore = dealerPlayer.score;
                    gamePlayers.map((player, i) => {
                        const found = self.players.find(p => p.account == player.playerAddress);
                        if (found) {
                            if (player.account != self.dealer) {
                                found.time = new Date(parseInt(player.joinTime.toString()) * 1000).toISOString();
                                found.stake = parseFloat(web3.utils.fromWei(player.stake, 'ether')).toFixed(3);
                            }
                            if (self.ended) {
                                if (player.score == 0n) // 通殺或通賠
                                {
                                    if (delearScore >= 12) {
                                        found.result = `莊家通殺! 損失 ${found.stake} ETH`;
                                        dealerBalance += parseFloat(found.stake);
                                    } else {
                                        found.result = `莊家通賠。獲利 ${found.stake} ETH`;
                                        dealerBalance -= parseFloat(found.stake);
                                    }
                                }
                                else {
                                    found.dice = player.diceRolls.join(',');
                                    found.score = player.score;
                                    found.payout = web3.utils.fromWei(player.payout, 'ether');

                                    if (player.payout == 0) {
                                        found.result = `殺! 損失 ${found.stake} ETH`;
                                        dealerBalance += parseFloat(found.stake);
                                    } else if (player.stake == player.payout) {
                                        found.result = `平手。退回 ${found.stake} ETH`;
                                    } else {
                                        found.result = `贏! 獲利 ${found.stake} ETH`;
                                        dealerBalance -= parseFloat(found.stake);
                                    }
                                }
                            }
                        };
                    });
                    dealerPlayer.result = `莊家損益: ${dealerBalance.toFixed(3)} ETH`;
                },
                async refreshBalances() {
                    this.players.map(player => {
                        web3.eth.getBalance(player.account).then(balance => {
                            player.balance = parseFloat(web3.utils.fromWei(balance, "ether")).toFixed(3);
                        });
                    });
                }
            }
        });
        app.mount('#app');
    </script>

</body>

</html>